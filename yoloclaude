#!/usr/bin/env python3
"""
yoloclaude - Run Claude Code in a sandboxed user environment

This script wraps Claude Code to run it as a separate 'claude' user,
providing containment through Unix permissions while allowing the agent
freedom to install packages and modify files within its own environment.
"""

import argparse
import hashlib
import json
import os
import re
import shlex
import subprocess
import sys
from dataclasses import dataclass, asdict, field
from datetime import datetime
from pathlib import Path
from typing import Optional
from urllib.parse import urlparse


# ANSI colors
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    CYAN = '\033[0;36m'
    NC = '\033[0m'  # No Color


def info(msg: str) -> None:
    print(f"{Colors.GREEN}[INFO]{Colors.NC} {msg}")


def warn(msg: str) -> None:
    print(f"{Colors.YELLOW}[WARN]{Colors.NC} {msg}")


def error(msg: str) -> None:
    print(f"{Colors.RED}[ERROR]{Colors.NC} {msg}")
    sys.exit(1)


# Global flag for non-interactive mode
AUTO_YES = False


def prompt(msg: str) -> str:
    """Prompt user for input."""
    return input(f"{Colors.CYAN}[?]{Colors.NC} {msg}: ")


def prompt_yes_no(msg: str, default: bool = True) -> bool:
    """Prompt user for yes/no answer. In auto-yes mode, always returns True."""
    if AUTO_YES:
        info(f"{msg} [auto-yes]")
        return True
    suffix = "[Y/n]" if default else "[y/N]"
    response = input(f"{Colors.CYAN}[?]{Colors.NC} {msg} {suffix}: ").strip().lower()
    if not response:
        return default
    return response in ('y', 'yes')


def get_claude_home() -> Path:
    """Get the claude user's home directory."""
    if sys.platform == "darwin":
        return Path("/Users/claude")
    return Path("/home/claude")


def get_user_repos_dir() -> Path:
    """Get the invoking user's repos directory."""
    return Path.home() / "repos"


def encode_claude_path(path: Path) -> str:
    """
    Encode a filesystem path to Claude's session directory format.
    /Users/dave/repos/myproject -> -Users-dave-repos-myproject
    """
    return str(path.resolve()).replace('/', '-')


def find_claude_sessions(repo_path: Path) -> list[dict]:
    """
    Find Claude sessions for a given repo path.
    Returns list of session info dicts with uuid, path, and modified time.
    Sorted by modification time, most recent first.
    """
    claude_dir = Path.home() / '.claude' / 'projects' / encode_claude_path(repo_path)
    if not claude_dir.exists():
        return []

    sessions = []
    for f in claude_dir.glob('*.jsonl'):
        # Skip summary files
        if f.name.startswith('session-summary'):
            continue
        sessions.append({
            'uuid': f.stem,
            'path': f,
            'modified': f.stat().st_mtime
        })
    return sorted(sessions, key=lambda s: s['modified'], reverse=True)


def format_session_time(mtime: float) -> str:
    """Format a modification time for display."""
    return datetime.fromtimestamp(mtime).strftime('%Y-%m-%d %H:%M:%S')


def import_claude_session(source_repo: Path, worktree_path: Path, session_uuid: Optional[str] = None) -> Optional[str]:
    """
    Import Claude session files from source repo to worktree location.

    Args:
        source_repo: Original repo path (invoking user's repo)
        worktree_path: yoloclaude worktree path (claude user's worktree)
        session_uuid: Specific session to import, or None for most recent

    Returns:
        The UUID of the imported session, or None if import failed.
    """
    # Find source sessions
    source_sessions = find_claude_sessions(source_repo)
    if not source_sessions:
        warn(f"No Claude sessions found for {source_repo}")
        return None

    # Select session to import
    if session_uuid:
        session = next((s for s in source_sessions if s['uuid'] == session_uuid), None)
        if not session:
            warn(f"Session {session_uuid} not found")
            return None
    else:
        session = source_sessions[0]  # Most recent

    # Create target directory (as claude user)
    claude_home = get_claude_home()
    target_dir = claude_home / '.claude' / 'projects' / encode_claude_path(worktree_path)

    # Create directory structure as claude user
    run_as_claude(['mkdir', '-p', str(target_dir)])

    # Copy session file(s)
    # We read the file as the invoking user and pipe it to claude user via tee,
    # since the claude user can't read the invoking user's ~/.claude directory
    source_file = session['path']
    target_file = target_dir / source_file.name

    info(f"Importing session {session['uuid']}")
    with open(source_file, 'rb') as f:
        content = f.read()
    subprocess.run(
        ['sudo', '-u', 'claude', 'tee', str(target_file)],
        input=content,
        stdout=subprocess.DEVNULL,
        check=True
    )

    # Also copy any summary files
    summary_file = source_file.parent / f"session-summary-{session['uuid']}.jsonl"
    if summary_file.exists():
        target_summary = target_dir / summary_file.name
        with open(summary_file, 'rb') as f:
            content = f.read()
        subprocess.run(
            ['sudo', '-u', 'claude', 'tee', str(target_summary)],
            input=content,
            stdout=subprocess.DEVNULL,
            check=True
        )

    return session['uuid']


def run_cmd(cmd: list[str], check: bool = True, capture: bool = False, **kwargs) -> subprocess.CompletedProcess:
    """Run a command and optionally capture output."""
    if capture:
        kwargs.setdefault('capture_output', True)
        kwargs.setdefault('text', True)
    result = subprocess.run(cmd, **kwargs)
    if check and result.returncode != 0:
        if capture:
            error(f"Command failed: {' '.join(cmd)}\n{result.stderr}")
        else:
            error(f"Command failed: {' '.join(cmd)}")
    return result


def run_as_claude(cmd: list[str], **kwargs) -> subprocess.CompletedProcess:
    """Run a command as the claude user."""
    # -H ensures HOME is set to claude's home (needed for git config, etc.)
    return run_cmd(['sudo', '-H', '-u', 'claude'] + cmd, **kwargs)


def path_exists_as_claude(path: Path) -> bool:
    """Check if a path exists, running the check as the claude user."""
    result = subprocess.run(
        ['sudo', '-u', 'claude', 'test', '-e', str(path)],
        capture_output=True
    )
    return result.returncode == 0


def is_git_repo_as_claude(path: Path) -> bool:
    """Check if a path is a git repository, running the check as the claude user."""
    result = subprocess.run(
        ['sudo', '-u', 'claude', 'test', '-d', str(path / '.git')],
        capture_output=True
    )
    return result.returncode == 0


# =============================================================================
# Session Management
# =============================================================================

@dataclass
class Session:
    """Represents a yoloclaude session with its associated worktree."""

    session_id: str
    project_name: str
    branch: str
    worktree_path: str
    origin_path: str
    created_at: str
    last_accessed: str
    claude_session_id: Optional[str] = None
    source_branch: str = "main"

    def to_dict(self) -> dict:
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict) -> 'Session':
        # Remove deprecated fields for backward compatibility
        data.pop("status", None)
        # Default source_branch for old sessions
        if "source_branch" not in data:
            data["source_branch"] = "main"
        return cls(**data)

    def save(self) -> None:
        """Save session to disk."""
        sessions_dir = get_sessions_dir()
        sessions_dir.mkdir(parents=True, exist_ok=True)
        session_file = sessions_dir / f"{self.session_id}.json"
        with open(session_file, 'w') as f:
            json.dump(self.to_dict(), f, indent=2)

    @classmethod
    def load(cls, session_id: str) -> Optional['Session']:
        """Load a session from disk."""
        session_file = get_sessions_dir() / f"{session_id}.json"
        if not session_file.exists():
            return None
        with open(session_file) as f:
            return cls.from_dict(json.load(f))


def get_sessions_dir() -> Path:
    """Get the directory where sessions are stored (in invoking user's home)."""
    return Path.home() / ".yoloclaude" / "sessions"


def generate_session_id() -> str:
    """Generate a short unique session ID."""
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    hash_suffix = hashlib.sha256(str(datetime.now().timestamp()).encode()).hexdigest()[:6]
    return f"{timestamp}-{hash_suffix}"


def generate_branch_name(source_branch: str) -> str:
    """Generate a default worktree branch name based on the source branch."""
    # Strip 'claude/' prefix to avoid 'claude/claude/...'
    base_name = source_branch
    if base_name.startswith('claude/'):
        base_name = base_name[len('claude/'):]

    # Truncate very long branch names
    MAX_BASE_LENGTH = 50
    if len(base_name) > MAX_BASE_LENGTH:
        base_name = base_name[:MAX_BASE_LENGTH]

    hash_suffix = hashlib.sha256(str(datetime.now().timestamp()).encode()).hexdigest()[:4]
    return f"claude/{base_name}-worktree-{hash_suffix}"


def create_session(
    project_name: str,
    branch: str,
    worktree_path: Path,
    origin_path: Path,
    source_branch: str,
    claude_session_id: Optional[str] = None,
) -> Session:
    """Create and save a new session."""
    now = datetime.now().isoformat()
    session = Session(
        session_id=generate_session_id(),
        project_name=project_name,
        branch=branch,
        worktree_path=str(worktree_path),
        origin_path=str(origin_path),
        created_at=now,
        last_accessed=now,
        claude_session_id=claude_session_id,
        source_branch=source_branch,
    )
    session.save()
    return session


def list_sessions(project_filter: Optional[str] = None) -> list[Session]:
    """List all sessions, optionally filtered by project name."""
    sessions_dir = get_sessions_dir()
    if not sessions_dir.exists():
        return []

    sessions = []
    for session_file in sessions_dir.glob("*.json"):
        try:
            with open(session_file) as f:
                session = Session.from_dict(json.load(f))
                if project_filter is None or session.project_name == project_filter:
                    sessions.append(session)
        except (json.JSONDecodeError, KeyError):
            warn(f"Skipping corrupted session file: {session_file}")

    # Sort by last_accessed, most recent first
    sessions.sort(key=lambda s: s.last_accessed, reverse=True)
    return sessions


def find_session(session_id_prefix: str) -> Optional[Session]:
    """Find a session by ID or prefix."""
    sessions_dir = get_sessions_dir()
    if not sessions_dir.exists():
        return None

    # Try exact match first
    exact_match = sessions_dir / f"{session_id_prefix}.json"
    if exact_match.exists():
        return Session.load(session_id_prefix)

    # Try prefix match
    matches = list(sessions_dir.glob(f"{session_id_prefix}*.json"))
    if len(matches) == 1:
        session_id = matches[0].stem
        return Session.load(session_id)
    elif len(matches) > 1:
        error(f"Ambiguous session ID prefix '{session_id_prefix}'. Matches: {[m.stem for m in matches]}")

    return None


# =============================================================================
# Worktree Management
# =============================================================================

def get_worktree_name(session: Session) -> str:
    """
    Extract worktree name from session's branch.
    Branch: 'claude/aerie-20260121-143022-ab12' -> Worktree name: 'aerie-20260121-143022-ab12'
    """
    branch = session.branch
    if branch.startswith('claude/'):
        return branch[len('claude/'):]
    return branch


def find_session_by_worktree(project_name: str, worktree_name: str) -> Optional[Session]:
    """
    Find a session by project name and worktree name.
    Supports prefix matching for worktree names.
    """
    sessions = list_sessions(project_filter=project_name)
    if not sessions:
        return None

    # Try exact match first
    for session in sessions:
        if get_worktree_name(session) == worktree_name:
            return session

    # Try prefix match
    matches = [s for s in sessions if get_worktree_name(s).startswith(worktree_name)]
    if len(matches) == 1:
        return matches[0]
    elif len(matches) > 1:
        worktree_names = [get_worktree_name(s) for s in matches]
        error(f"Ambiguous worktree prefix '{worktree_name}'. Matches: {worktree_names}")

    return None


def resolve_project_name(name: str) -> Optional[Path]:
    """
    Resolve a project name to its origin path.
    1. First check ~/repos/<name>
    2. Then scan existing sessions for matching project_name and use its origin_path
    """
    repos_dir = get_user_repos_dir()

    # Check ~/repos/ first
    repo_path = repos_dir / name
    if repo_path.exists() and (repo_path / '.git').exists():
        return repo_path

    # Check existing sessions
    sessions = list_sessions(project_filter=name)
    if sessions:
        # Use the most recently accessed session's origin path
        origin_path = Path(sessions[0].origin_path)
        if origin_path.exists():
            return origin_path

    return None


def check_worktree_status(session: Session) -> str:
    """
    Check the status of a worktree.
    Returns: 'clean', 'modified', or 'missing'
    """
    worktree_path = Path(session.worktree_path)

    # Check if worktree directory exists
    if not path_exists_as_claude(worktree_path):
        return "missing"

    # Check for uncommitted changes
    result = run_as_claude(
        ['git', '-C', str(worktree_path), 'status', '--porcelain'],
        capture=True, check=False
    )

    if result.returncode != 0:
        return "missing"  # Git command failed, probably not a valid repo

    if result.stdout.strip():
        return "modified"

    return "clean"


def get_origin_current_branch(origin_path: Path) -> str:
    """Get the currently checked-out branch in the origin repo."""
    result = run_cmd(
        ['git', '-C', str(origin_path), 'rev-parse', '--abbrev-ref', 'HEAD'],
        capture=True, check=False
    )
    if result.returncode == 0 and result.stdout.strip() != 'HEAD':
        return result.stdout.strip()
    return 'main'  # Fallback


def list_origin_branches(origin_path: Path) -> list[str]:
    """List branches available in origin repo."""
    result = run_cmd(
        ['git', '-C', str(origin_path), 'branch', '-r', '--format=%(refname:short)'],
        capture=True, check=False
    )
    if result.returncode != 0:
        return ['main']
    branches = []
    for line in result.stdout.strip().split('\n'):
        line = line.strip()
        if line.startswith('origin/') and not line.endswith('/HEAD'):
            branches.append(line.replace('origin/', ''))
    return branches or ['main']


def prompt_source_branch(origin_path: Path) -> str:
    """Prompt user to select which branch to base the worktree on."""
    current = get_origin_current_branch(origin_path)
    branches = list_origin_branches(origin_path)

    if AUTO_YES:
        info(f"Source branch: {current} [auto]")
        return current

    print()
    info(f"Source branch: {current}")
    info(f"Available branches: {', '.join(branches[:5])}" +
         (f" (+{len(branches)-5} more)" if len(branches) > 5 else ""))
    branch = prompt(f"Source branch (Enter for {current})")
    return branch.strip() if branch.strip() else current


def get_worktree_origin_status(session: Session) -> dict:
    """Get worktree status relative to its source branch."""
    worktree_path = Path(session.worktree_path)
    source_branch = session.source_branch

    if not path_exists_as_claude(worktree_path):
        return {'behind': 0, 'ahead': 0, 'can_ff': False, 'error': 'missing'}

    # Fetch origin
    run_as_claude(['git', '-C', str(worktree_path), 'fetch', 'origin'], check=False, capture=True)

    upstream = f'origin/{source_branch}'

    # Verify upstream exists
    check = run_as_claude(
        ['git', '-C', str(worktree_path), 'rev-parse', '--verify', upstream],
        capture=True, check=False
    )
    if check.returncode != 0:
        return {'behind': 0, 'ahead': 0, 'can_ff': False, 'error': f'{source_branch} not found'}

    # Get ahead/behind counts
    result = run_as_claude(
        ['git', '-C', str(worktree_path), 'rev-list', '--left-right', '--count', f'{upstream}...HEAD'],
        capture=True, check=False
    )
    if result.returncode != 0:
        return {'behind': 0, 'ahead': 0, 'can_ff': False, 'error': 'comparison failed'}

    parts = result.stdout.strip().split()
    behind = int(parts[0]) if parts else 0
    ahead = int(parts[1]) if len(parts) >= 2 else 0
    can_ff = behind > 0 and ahead == 0

    return {'behind': behind, 'ahead': ahead, 'can_ff': can_ff, 'error': None}


def display_worktrees(sessions: list[Session]) -> None:
    """Display worktrees in a table format with status."""
    if not sessions:
        info("No worktrees found for this project.")
        return

    print()
    print(f"{'#':<3} {'Worktree Name':<32} {'Base':<12} {'Status':<10} {'vs Origin':<18}")
    print("-" * 78)

    for i, session in enumerate(sessions, 1):
        worktree_name = get_worktree_name(session)
        if len(worktree_name) > 30:
            worktree_name = worktree_name[:27] + "..."

        base_branch = session.source_branch
        if len(base_branch) > 10:
            base_branch = base_branch[:7] + "..."

        status = check_worktree_status(session)
        status_str = {
            "clean": f"{Colors.GREEN}clean{Colors.NC}",
            "modified": f"{Colors.YELLOW}modified{Colors.NC}",
            "missing": f"{Colors.RED}missing{Colors.NC}",
        }.get(status, status)

        # Get origin status
        if status != "missing":
            origin = get_worktree_origin_status(session)
            if origin.get('error'):
                origin_str = f"({origin['error']})"
            elif origin['behind'] == 0 and origin['ahead'] == 0:
                origin_str = f"{Colors.GREEN}up-to-date{Colors.NC}"
            else:
                parts = []
                if origin['behind'] > 0:
                    parts.append(f"{Colors.YELLOW}{origin['behind']} behind{Colors.NC}")
                if origin['ahead'] > 0:
                    parts.append(f"{Colors.CYAN}{origin['ahead']} ahead{Colors.NC}")
                origin_str = ", ".join(parts)
        else:
            origin_str = ""

        print(f"{i:<3} {worktree_name:<32} {base_branch:<12} {status_str:<10} {origin_str}")

    print()


def remove_worktree(session: Session, force: bool = False) -> bool:
    """
    Safely remove a worktree and its session.
    Returns True if successful, False if cancelled.

    - Warns if worktree has uncommitted changes (unless force=True)
    - Runs `git worktree remove` as claude user
    - Deletes the branch
    - Deletes session JSON file
    """
    worktree_path = Path(session.worktree_path)
    status = check_worktree_status(session)

    # Warn about uncommitted changes
    if status == "modified" and not force:
        warn(f"Worktree '{get_worktree_name(session)}' has uncommitted changes!")
        if not prompt_yes_no("Remove anyway? (changes will be lost)"):
            return False

    # Get the base repo path (claude's clone)
    claude_home = get_claude_home()
    base_repo = claude_home / "projects" / session.project_name

    # Remove the worktree if it exists
    if status != "missing":
        info(f"Removing worktree: {worktree_path}")
        result = run_as_claude(
            ['git', '-C', str(base_repo), 'worktree', 'remove', '--force', str(worktree_path)],
            check=False, capture=True
        )
        if result.returncode != 0:
            # Fall back to rm -rf
            warn(f"git worktree remove failed, removing directory directly")
            run_as_claude(['rm', '-rf', str(worktree_path)], check=False)
            # Prune worktree list
            run_as_claude(['git', '-C', str(base_repo), 'worktree', 'prune'], check=False)

    # Delete the branch
    branch = session.branch
    info(f"Deleting branch: {branch}")
    run_as_claude(
        ['git', '-C', str(base_repo), 'branch', '-D', branch],
        check=False, capture=True
    )

    # Delete session file
    session_file = get_sessions_dir() / f"{session.session_id}.json"
    if session_file.exists():
        info(f"Removing session file: {session_file}")
        session_file.unlink()

    info(f"Worktree '{get_worktree_name(session)}' removed successfully.")
    return True


def remove_all_worktrees(project_name: str, force: bool = False) -> int:
    """
    Remove all worktrees for a project.
    Returns the number of worktrees removed.
    """
    sessions = list_sessions(project_filter=project_name)
    if not sessions:
        info(f"No worktrees found for project '{project_name}'.")
        return 0

    # Display worktrees
    print()
    info(f"Found {len(sessions)} worktree(s) for project '{project_name}':")
    display_worktrees(sessions)

    # Check for modified worktrees
    modified = [s for s in sessions if check_worktree_status(s) == "modified"]
    if modified and not force:
        warn(f"{len(modified)} worktree(s) have uncommitted changes!")

    if not force:
        if not prompt_yes_no(f"Remove all {len(sessions)} worktree(s)?", default=False):
            info("Cancelled.")
            return 0

    removed = 0
    for session in sessions:
        if remove_worktree(session, force=True):  # force=True since we already confirmed
            removed += 1

    info(f"Removed {removed} of {len(sessions)} worktree(s).")
    return removed


def prompt_worktree_choice(sessions: list[Session]) -> Optional[Session]:
    """
    Interactive menu to choose a worktree or create a new one.
    Returns the selected session, or None if user wants to create a new worktree.
    Skips prompt in non-interactive mode (--yes flag) and returns None.
    """
    if AUTO_YES:
        info("Creating new worktree [auto-yes mode]")
        return None

    if not sessions:
        return None

    print()
    info("Existing worktrees for this project:")
    display_worktrees(sessions)

    print("Options:")
    print("  [1-N] Resume a worktree by number")
    print("  [n]   Create a new worktree")
    print("  [q]   Quit")
    print()

    while True:
        choice = prompt("Your choice").strip().lower()

        if choice == 'q':
            info("Exiting.")
            sys.exit(0)

        if choice == 'n':
            return None  # Create new worktree

        # Try to parse as number
        try:
            num = int(choice)
            if 1 <= num <= len(sessions):
                return sessions[num - 1]
            else:
                warn(f"Invalid number. Please enter 1-{len(sessions)}, 'n', or 'q'.")
        except ValueError:
            warn("Invalid choice. Please enter a number, 'n', or 'q'.")


def is_git_url(repo: str) -> bool:
    """Check if the repo argument looks like a git URL."""
    # HTTPS URLs
    if repo.startswith(('https://', 'http://')):
        return True
    # SSH URLs (git@github.com:user/repo)
    if re.match(r'^[\w-]+@[\w.-]+:[\w./-]+$', repo):
        return True
    # git:// protocol
    if repo.startswith('git://'):
        return True
    return False


def extract_repo_name(repo: str) -> str:
    """Extract repository name from URL or path."""
    # Remove .git suffix if present
    repo = repo.rstrip('/')
    if repo.endswith('.git'):
        repo = repo[:-4]

    # Handle URLs
    if '://' in repo:
        parsed = urlparse(repo)
        path = parsed.path
    elif ':' in repo:
        # SSH URL format: git@github.com:user/repo
        path = repo.split(':')[-1]
    else:
        path = repo

    return Path(path).name


def check_sudo_access() -> None:
    """Verify we can sudo to the claude user."""
    result = subprocess.run(
        ['sudo', '-n', '-u', 'claude', 'true'],
        capture_output=True
    )
    if result.returncode != 0:
        error(
            "Cannot sudo to claude user without password.\n"
            "Have you run yoloclaude-setup? You may need to run:\n"
            "  sudo yoloclaude-setup"
        )


def ensure_user_repo(repo_url: str, repos_dir: Path) -> Path:
    """
    Ensure the repo is cloned to the invoking user's repos directory.
    Returns the path to the local clone.
    """
    repo_name = extract_repo_name(repo_url)
    local_path = repos_dir / repo_name

    if local_path.exists():
        if not (local_path / '.git').exists():
            error(f"{local_path} exists but is not a git repository")
        info(f"Using existing local clone: {local_path}")

        # Optionally fetch latest
        if prompt_yes_no("Fetch latest changes from remote?"):
            info("Fetching latest changes...")
            run_cmd(['git', '-C', str(local_path), 'fetch', '--all'])
    else:
        # Create repos directory if needed
        repos_dir.mkdir(parents=True, exist_ok=True)

        info(f"Cloning {repo_url} to {local_path}...")
        run_cmd(['git', 'clone', repo_url, str(local_path)])

    return local_path


def ensure_repo_accessible_to_claude(repo_path: Path) -> None:
    """
    Ensure the repository is readable by the claude user.
    This may require adjusting directory permissions along the path.

    Note: The origin repo intentionally stays READ-ONLY to claude for sandbox
    isolation. At session end, yoloclaude (as the invoking user) fetches
    commits from claude's worktree rather than having claude push.
    """
    # Check if claude can access the repo
    result = subprocess.run(
        ['sudo', '-u', 'claude', 'test', '-r', str(repo_path)],
        capture_output=True
    )
    if result.returncode == 0:
        return  # Already accessible

    warn(f"Repository at {repo_path} is not accessible to claude user.")
    info("Making repository readable...")

    # Make each component of the path readable
    # Start from the repo and work up to find the first accessible parent
    path = repo_path
    paths_to_fix = []
    while path != path.parent:
        result = subprocess.run(
            ['sudo', '-u', 'claude', 'test', '-x', str(path)],
            capture_output=True
        )
        if result.returncode == 0:
            break
        paths_to_fix.append(path)
        path = path.parent

    # Fix permissions from top to bottom
    for p in reversed(paths_to_fix):
        run_cmd(['chmod', 'o+rx', str(p)])

    # Make the .git directory readable
    git_dir = repo_path / '.git'
    if git_dir.exists():
        run_cmd(['chmod', '-R', 'o+rX', str(git_dir)])


def ensure_claude_clone(origin_path: Path) -> Path:
    """
    Ensure the repo is cloned to claude's projects directory.
    The clone's origin will point to origin_path (the invoking user's local repo).
    Returns the path to claude's clone.
    """
    # First ensure claude can read the origin repo
    ensure_repo_accessible_to_claude(origin_path)

    claude_home = get_claude_home()
    projects_dir = claude_home / "projects"
    repo_name = origin_path.name
    claude_repo_path = projects_dir / repo_name

    if path_exists_as_claude(claude_repo_path):
        if not is_git_repo_as_claude(claude_repo_path):
            error(f"{claude_repo_path} exists but is not a git repository")

        # Verify origin points to the right place
        result = run_as_claude(
            ['git', '-C', str(claude_repo_path), 'remote', 'get-url', 'origin'],
            capture=True, check=False
        )
        current_origin = result.stdout.strip() if result.returncode == 0 else ""

        if current_origin != str(origin_path):
            warn(f"Claude's clone has different origin: {current_origin}")
            if prompt_yes_no(f"Update origin to {origin_path}?"):
                run_as_claude(['git', '-C', str(claude_repo_path), 'remote', 'set-url', 'origin', str(origin_path)])

        info(f"Using existing claude clone: {claude_repo_path}")

        # Fetch from origin
        info("Fetching latest from local origin...")
        run_as_claude(['git', '-C', str(claude_repo_path), 'fetch', 'origin'])

        # Check if we should pull
        result = run_as_claude(
            ['git', '-C', str(claude_repo_path), 'status', '-uno'],
            capture=True
        )
        if 'behind' in result.stdout:
            if prompt_yes_no("Claude's clone is behind origin. Pull changes?"):
                run_as_claude(['git', '-C', str(claude_repo_path), 'pull', '--ff-only'])
    else:
        info(f"Cloning {origin_path} to {claude_repo_path}...")
        run_as_claude(['git', 'clone', str(origin_path), str(claude_repo_path)])

    return claude_repo_path


def create_worktree(base_repo: Path, origin_path: Path, branch_name: str, source_branch: str) -> Path:
    """
    Create a git worktree for a new session.
    Returns the path to the worktree.
    """
    worktrees_dir = base_repo / "worktrees"
    worktree_path = worktrees_dir / branch_name.replace('/', '-')

    # Create worktrees directory if needed
    run_as_claude(['mkdir', '-p', str(worktrees_dir)])

    # Fetch latest from origin first
    info("Fetching latest from origin...")
    run_as_claude(['git', '-C', str(base_repo), 'fetch', 'origin'])

    # Create the worktree with a new branch based on specified source branch
    info(f"Creating worktree for branch '{branch_name}' (based on {source_branch})...")
    run_as_claude([
        'git', '-C', str(base_repo),
        'worktree', 'add',
        '-b', branch_name,
        str(worktree_path),
        f'origin/{source_branch}'
    ])

    return worktree_path


def prompt_branch_name(source_branch: str) -> str:
    """Prompt for a worktree branch name with an auto-generated default."""
    default_name = generate_branch_name(source_branch)

    if AUTO_YES:
        info(f"Worktree branch: {default_name} [auto]")
        return default_name

    print()
    info(f"Worktree branch: {default_name}")
    custom_name = prompt("Worktree branch name (Enter for default)")

    if custom_name.strip():
        # Ensure branch name has claude/ prefix for clarity
        if not custom_name.startswith('claude/'):
            custom_name = f"claude/{custom_name}"
        return custom_name
    return default_name


def start_new_session(origin_path: Path, claude_args: list[str], shell_mode: bool = False) -> tuple[Session, int]:
    """
    Start a new yoloclaude session with a fresh worktree.
    Returns the session and the exit code.
    """
    project_name = origin_path.name

    # Ensure base clone exists
    base_repo = ensure_claude_clone(origin_path)

    # Prompt for source branch
    source_branch = prompt_source_branch(origin_path)

    # Get worktree branch name from user
    branch_name = prompt_branch_name(source_branch)

    # Create worktree based on source branch
    worktree_path = create_worktree(base_repo, origin_path, branch_name, source_branch)

    # Create session record
    session = create_session(
        project_name=project_name,
        branch=branch_name,
        worktree_path=worktree_path,
        origin_path=origin_path,
        source_branch=source_branch,
    )

    info(f"Session ID: {session.session_id}")

    # Run Claude Code or shell
    if shell_mode:
        exit_code = run_shell_session(worktree_path)
    else:
        exit_code = run_claude_session(worktree_path, claude_args, session)

    # Handle end of session
    handle_end_of_session(worktree_path, origin_path, session)

    return session, exit_code


def resume_session(session: Session, claude_args: list[str], shell_mode: bool = False) -> int:
    """
    Resume an existing session.
    Returns the exit code.
    """
    worktree_path = Path(session.worktree_path)
    origin_path = Path(session.origin_path)

    # Verify worktree still exists
    if not path_exists_as_claude(worktree_path):
        error(f"Worktree no longer exists: {worktree_path}")

    # Ensure origin is still accessible
    ensure_repo_accessible_to_claude(origin_path)

    # Check origin status and offer fast-forward
    origin_status = get_worktree_origin_status(session)

    if origin_status.get('error'):
        warn(f"Could not check origin status: {origin_status['error']}")
    elif origin_status['behind'] > 0 and origin_status['ahead'] > 0:
        warn(f"Worktree has diverged from {session.source_branch} "
             f"({origin_status['behind']} behind, {origin_status['ahead']} ahead)")
    elif origin_status.get('can_ff'):
        if check_worktree_status(session) == "modified":
            warn("Worktree has uncommitted changes. Skipping fast-forward.")
        else:
            info(f"Worktree is {origin_status['behind']} commit(s) behind {session.source_branch}.")
            if prompt_yes_no("Fast-forward to latest?"):
                result = run_as_claude(
                    ['git', '-C', str(worktree_path), 'merge', '--ff-only', f'origin/{session.source_branch}'],
                    capture=True, check=False
                )
                if result.returncode == 0:
                    info("Fast-forwarded to latest.")
                else:
                    warn(f"Fast-forward failed: {result.stderr.strip()}")

    # Update last accessed
    session.last_accessed = datetime.now().isoformat()
    session.save()

    info(f"Resuming session: {session.session_id}")
    info(f"Project: {session.project_name}")
    info(f"Branch: {session.branch} (based on {session.source_branch})")

    # Run Claude Code or shell
    if shell_mode:
        exit_code = run_shell_session(worktree_path)
    else:
        # Run Claude Code with --resume if we have a claude session ID
        if session.claude_session_id:
            claude_args = ['--resume', session.claude_session_id] + list(claude_args)
        exit_code = run_claude_session(worktree_path, claude_args, session)

    # Handle end of session
    handle_end_of_session(worktree_path, origin_path, session)

    return exit_code


def display_sessions(sessions: list[Session]) -> None:
    """Display a list of sessions in a table format."""
    if not sessions:
        info("No sessions found.")
        return

    print()
    print(f"{'ID':<20} {'Project':<20} {'Branch':<35} {'Last Accessed':<20}")
    print("-" * 95)
    for s in sessions:
        # Truncate long values
        session_id = s.session_id[:18] + ".." if len(s.session_id) > 20 else s.session_id
        project = s.project_name[:18] + ".." if len(s.project_name) > 20 else s.project_name
        branch = s.branch[:33] + ".." if len(s.branch) > 35 else s.branch
        last_accessed = s.last_accessed[:19]  # Just the datetime part
        print(f"{session_id:<20} {project:<20} {branch:<35} {last_accessed:<20}")
    print()


def get_claude_binary_path() -> str:
    """
    Get the path to the claude binary for the claude user.

    We use an explicit path rather than relying on PATH because sudo -i
    on macOS can inherit PATH from the invoking user, causing it to find
    the wrong claude installation.
    """
    claude_home = get_claude_home()
    claude_bin = claude_home / ".local" / "bin" / "claude"

    # Check if claude is installed in the expected location
    if path_exists_as_claude(claude_bin):
        return str(claude_bin)

    # Fall back to just 'claude' and hope PATH is correct
    warn(f"Claude not found at {claude_bin}, falling back to PATH lookup")
    return "claude"


def fix_feature_flags(claude_home: Path) -> None:
    """
    Fix feature flags in Claude's config that cause hanging when enabled.

    Some feature flags (tengu_mcp_tool_search, tengu_scratch) enable features
    that don't work properly when running as a sandboxed user, causing Claude
    to hang on startup. This function disables those flags.
    """
    config_path = claude_home / ".claude.json"

    # Read the config file as claude user
    result = subprocess.run(
        ['sudo', '-H', '-u', 'claude', 'cat', str(config_path)],
        capture_output=True,
        text=True
    )

    if result.returncode != 0:
        return  # Config doesn't exist yet, nothing to fix

    try:
        config = json.loads(result.stdout)
    except json.JSONDecodeError:
        return  # Invalid JSON, skip

    # Check if we need to fix any flags
    features = config.get("cachedGrowthBookFeatures", {})
    needs_fix = False

    # Flags that cause hanging when enabled
    problematic_flags = ["tengu_mcp_tool_search", "tengu_scratch"]

    for flag in problematic_flags:
        if features.get(flag) == True:
            features[flag] = False
            needs_fix = True

    if not needs_fix:
        return

    # Write the fixed config back
    config["cachedGrowthBookFeatures"] = features
    config_json = json.dumps(config, indent=2)

    # Use a temp file and move to avoid permission issues
    result = subprocess.run(
        ['sudo', '-H', '-u', 'claude', 'bash', '-c',
         f'cat > {shlex.quote(str(config_path))}'],
        input=config_json,
        text=True,
        capture_output=True
    )

    if result.returncode != 0:
        warn(f"Failed to update Claude config: {result.stderr}")


def prepare_sandbox_environment() -> str:
    """
    Prepare the sandbox environment for running commands as claude user.
    Returns a shell command preamble that sets up PATH, keychain, etc.

    This is used both for Claude Code sessions and shell sessions,
    so that users can run `claude` manually from shell mode.
    """
    claude_home = get_claude_home()
    clean_path = f"{claude_home}/.local/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"

    # Fix feature flags that cause hanging when enabled
    fix_feature_flags(claude_home)

    preamble = f'export PATH={shlex.quote(clean_path)}'

    # On macOS, unlock the keychain
    if sys.platform == "darwin":
        keychain_path = f"{claude_home}/Library/Keychains/login.keychain-db"
        preamble = f'security unlock-keychain -p "claude" {shlex.quote(keychain_path)} 2>/dev/null || true; {preamble}'

    return preamble


def run_claude_session(project_path: Path, claude_args: list[str], session: Optional[Session] = None) -> int:
    """
    Run Claude Code as the claude user in the project directory.
    Returns the exit code.
    """
    info(f"Starting Claude Code session in {project_path}")
    info("Running as user: claude")
    print()

    preamble = prepare_sandbox_environment()
    claude_bin = get_claude_binary_path()

    args_str = " ".join(shlex.quote(arg) for arg in claude_args)
    cmd = [
        'sudo', '-H', '-u', 'claude',
        'bash', '-c',
        f'{preamble} && cd {shlex.quote(str(project_path))} && {shlex.quote(claude_bin)} --dangerously-skip-permissions {args_str}'
    ]

    # Run from /tmp to avoid Claude Code picking up .claude settings from the
    # invoking directory (which claude user may not have access to)
    result = subprocess.run(cmd, cwd="/tmp")
    return result.returncode


def run_shell_session(project_path: Path) -> int:
    """
    Run an interactive shell as the claude user in the project directory.
    Returns the exit code.
    """
    info(f"Starting shell session in {project_path}")
    info("Running as user: claude")
    info("Tip: You can run 'claude' from this shell if needed")
    print()

    preamble = prepare_sandbox_environment()

    cmd = [
        'sudo', '-H', '-u', 'claude',
        'bash', '-c',
        f'{preamble} && cd {shlex.quote(str(project_path))} && exec bash -l'
    ]

    result = subprocess.run(cmd, cwd="/tmp")
    return result.returncode


def _sync_commits_via_bundle(claude_repo_path: Path, origin_path: Path, branch: str) -> None:
    """
    Sync commits from claude's worktree to origin using a git bundle.

    We use a bundle because direct fetch fails due to git's "dubious ownership"
    check - the -c safe.directory option doesn't propagate to the git-upload-pack
    subprocess that runs in the worktree.

    The bundle is created in /tmp (world-accessible) rather than inside the
    worktree, because the invoking user may not have traverse permission
    through /home/claude.
    """
    bundle_path = f'/tmp/yoloclaude-sync-{os.getpid()}-{branch.replace("/", "-")}.bundle'
    try:
        info(f"Syncing changes to {origin_path}...")
        # Create bundle as claude (who owns the worktree)
        run_as_claude([
            'git', '-C', str(claude_repo_path),
            'bundle', 'create', bundle_path, branch
        ])
        # Make bundle readable by invoking user (in case umask restricted it)
        run_as_claude(['chmod', '644', bundle_path])
        # Fetch from bundle as invoking user (who owns origin)
        run_cmd([
            'git', '-C', str(origin_path),
            'fetch', bundle_path, f'{branch}:{branch}'
        ])
    finally:
        # Clean up bundle (as claude since claude owns it)
        run_as_claude(['rm', '-f', bundle_path], check=False)
    info("Changes synced to your local repo.")


def _offer_merge_to_source(origin_path: Path, branch: str, source_branch: str) -> None:
    """Offer to merge the worktree branch into the source branch if possible."""
    current_in_origin = get_origin_current_branch(origin_path)

    if current_in_origin == source_branch:
        # Source branch is checked out - can offer merge
        ff_check = run_cmd(
            ['git', '-C', str(origin_path), 'merge-base', '--is-ancestor', source_branch, branch],
            check=False, capture=True
        )
        print()
        if ff_check.returncode == 0:
            if prompt_yes_no(f"Merge '{branch}' into '{source_branch}'? (fast-forward)"):
                run_cmd(['git', '-C', str(origin_path), 'merge', '--ff-only', branch])
                info(f"Merged into {source_branch}.")
        else:
            info(f"Branch '{branch}' can't be fast-forwarded into '{source_branch}'.")
            info(f"To merge manually: git checkout {source_branch} && git merge {branch}")
    else:
        info(f"Source branch '{source_branch}' is not checked out in origin.")
        info(f"To merge: git checkout {source_branch} && git merge {branch}")


def _offer_push_to_remote(origin_path: Path) -> None:
    """Offer to push to remote if one exists."""
    result = run_cmd(
        ['git', '-C', str(origin_path), 'remote', 'get-url', 'origin'],
        capture=True, check=False
    )
    if result.returncode == 0 and result.stdout.strip():
        print()
        if prompt_yes_no("Push to remote?"):
            current_branch_result = run_cmd(
                ['git', '-C', str(origin_path), 'rev-parse', '--abbrev-ref', 'HEAD'],
                capture=True, check=False
            )
            if current_branch_result.returncode == 0:
                push_branch = current_branch_result.stdout.strip()
                run_cmd(['git', '-C', str(origin_path), 'push', 'origin', push_branch])
                info(f"Pushed {push_branch} to remote!")


def handle_end_of_session(claude_repo_path: Path, origin_path: Path, session: Session) -> None:
    """Handle git sync at end of session."""
    print()
    info("Session ended. Checking for changes...")

    source_branch = session.source_branch

    # Check for uncommitted changes
    result = run_as_claude(
        ['git', '-C', str(claude_repo_path), 'status', '--porcelain'],
        capture=True
    )
    if result.stdout.strip():
        warn("There are uncommitted changes in the working directory:")
        run_as_claude(['git', '-C', str(claude_repo_path), 'status', '--short'])
        print()

    # Fetch from origin to get accurate view of what's already synced
    run_as_claude(
        ['git', '-C', str(claude_repo_path), 'fetch', 'origin'],
        check=False, capture=True
    )

    # Check for unpushed commits relative to source branch
    result = run_as_claude(
        ['git', '-C', str(claude_repo_path), 'log', '--oneline', f'origin/{source_branch}..HEAD'],
        capture=True, check=False
    )
    unpushed_commits = result.stdout.strip() if result.returncode == 0 else ""

    if not unpushed_commits:
        info("No unpushed commits.")
        return

    print()
    info("Unpushed commits:")
    print(unpushed_commits)
    print()

    if not prompt_yes_no("Sync these commits to your local repo?"):
        return

    # Get the current branch name from the worktree
    branch_result = run_as_claude(
        ['git', '-C', str(claude_repo_path), 'rev-parse', '--abbrev-ref', 'HEAD'],
        capture=True
    )
    branch = branch_result.stdout.strip()

    _sync_commits_via_bundle(claude_repo_path, origin_path, branch)
    _offer_merge_to_source(origin_path, branch, source_branch)
    _offer_push_to_remote(origin_path)


# =============================================================================
# Repo Resolution
# =============================================================================

def resolve_repo_path(repo: str) -> Path:
    """
    Resolve a repo argument to a local path.

    Handles:
    - Git URLs (clones to ~/repos/ first)
    - Local directory paths
    - Project names in ~/repos/
    - Project names from previous sessions (memory feature)

    Returns the resolved Path or exits with error.
    """
    repos_dir = get_user_repos_dir()

    if is_git_url(repo):
        # Remote URL - clone to user's repos dir first
        return ensure_user_repo(repo, repos_dir)

    if os.path.isdir(repo):
        # Local directory path
        path = Path(repo).resolve()
        if not (path / '.git').exists():
            error(f"{path} is not a git repository")
        return path

    if os.path.isdir(repos_dir / repo):
        # Project name that exists in repos dir
        path = repos_dir / repo
        if not (path / '.git').exists():
            error(f"{path} is not a git repository")
        return path

    # Try to resolve via "memory" feature (previous sessions)
    resolved = resolve_project_name(repo)
    if resolved:
        info(f"Resolved '{repo}' from previous session")
        return resolved

    error(
        f"Cannot find repository: {repo}\n"
        "Provide a git URL, local path, or existing project name in ~/repos/"
    )


# =============================================================================
# CLI Command Handlers
# =============================================================================

def cmd_list_sessions() -> None:
    """Handle --list command."""
    sessions = list_sessions()
    display_sessions(sessions)


def cmd_list_worktrees(project_name: str) -> None:
    """Handle --list-worktrees command."""
    sessions = list_sessions(project_filter=project_name)
    if not sessions:
        info(f"No worktrees found for project '{project_name}'.")
    else:
        info(f"Worktrees for project '{project_name}':")
        display_worktrees(sessions)


def cmd_clear_worktree(project_name: str, worktree_name: str) -> None:
    """Handle --clear-worktree command."""
    session = find_session_by_worktree(project_name, worktree_name)
    if not session:
        error(f"Worktree '{worktree_name}' not found for project '{project_name}'")
    remove_worktree(session)


def cmd_clear_worktrees(project_name: str) -> None:
    """Handle --clear-worktrees command."""
    remove_all_worktrees(project_name)


def cmd_resume(session_id: Optional[str], claude_args: list[str], shell_mode: bool = False) -> int:
    """
    Handle --resume command.
    Returns exit code.
    """
    if session_id is None:
        # Show list and let user pick
        sessions = list_sessions()
        if not sessions:
            error("No sessions to resume. Start a new session first.")

        display_sessions(sessions)

        if AUTO_YES:
            session = sessions[0]
            info(f"Auto-resuming most recent session: {session.session_id}")
        else:
            user_input = prompt("Enter session ID to resume (or press Enter for most recent)")
            if user_input.strip():
                session = find_session(user_input.strip())
                if not session:
                    error(f"Session not found: {user_input}")
            else:
                session = sessions[0]
    else:
        session = find_session(session_id)
        if not session:
            error(f"Session not found: {session_id}")

    return resume_session(session, claude_args, shell_mode)


def cmd_worktree_resume(project_name: str, worktree_name: str, claude_args: list[str], shell_mode: bool = False) -> int:
    """
    Handle -w/--worktree command.
    Returns exit code.
    """
    session = find_session_by_worktree(project_name, worktree_name)
    if not session:
        error(f"Worktree '{worktree_name}' not found for project '{project_name}'")
    return resume_session(session, claude_args, shell_mode)


def cmd_start_session(origin_path: Path, claude_args: list[str], shell_mode: bool = False) -> int:
    """
    Start a new session or prompt to resume existing.
    Returns exit code.
    """
    project_name = origin_path.name

    # Check for existing worktrees and prompt user
    existing_sessions = list_sessions(project_filter=project_name)
    if existing_sessions:
        selected_session = prompt_worktree_choice(existing_sessions)
        if selected_session:
            return resume_session(selected_session, claude_args, shell_mode)

    # Start new session with worktree
    _, exit_code = start_new_session(origin_path, claude_args, shell_mode)
    return exit_code


def cmd_import_claude(import_path: Path, session_uuid: Optional[str], claude_args: list[str]) -> int:
    """
    Handle --import-claude command.
    Import a Claude session from a local repo into yoloclaude sandbox.
    Returns exit code from Claude.
    """
    # Validate import path
    if not import_path.exists():
        error(f"Path does not exist: {import_path}")
    if not (import_path / '.git').exists():
        error(f"Not a git repo: {import_path}")

    # Check for existing sessions
    sessions = find_claude_sessions(import_path)
    if not sessions:
        error(
            f"No Claude sessions found for {import_path}\n"
            "Run 'claude' in that directory first to create a session."
        )

    # Show available sessions
    if len(sessions) > 1 and not session_uuid:
        info(f"Found {len(sessions)} sessions:")
        for i, s in enumerate(sessions[:5]):
            print(f"  {i+1}. {s['uuid']} (modified: {format_session_time(s['modified'])})")
        if len(sessions) > 5:
            print(f"  ... and {len(sessions) - 5} more")
        print()
        info("Using most recent session. Use --session <id> to import a specific one.")
        print()
    elif session_uuid:
        # Verify the session exists
        if not any(s['uuid'] == session_uuid for s in sessions):
            error(f"Session {session_uuid} not found for {import_path}")

    # Set up yoloclaude environment
    origin_path = import_path.resolve()
    project_name = origin_path.name

    info(f"Import from: {origin_path}")
    info(f"Project: {project_name}")

    # Ensure origin is accessible and create claude's clone
    ensure_repo_accessible_to_claude(origin_path)
    base_repo = ensure_claude_clone(origin_path)

    # Auto-detect source branch (don't prompt since we're rsyncing current state)
    source_branch = get_origin_current_branch(origin_path)
    info(f"Source branch: {source_branch}")

    # Get worktree branch name
    branch_name = prompt_branch_name(source_branch)

    # Create worktree based on source branch
    worktree_path = create_worktree(base_repo, origin_path, branch_name, source_branch)

    # Sync uncommitted changes from origin to worktree
    # This ensures the worktree has the same working state as the origin,
    # not just the same committed state
    # Exclude: .git (managed separately), .claude (user-specific settings),
    # and cache directories (regenerated automatically, may have restricted perms)
    info("Syncing uncommitted changes from origin...")
    run_as_claude([
        'rsync', '-a', '--delete',
        '--exclude=.git',
        '--exclude=.claude',
        '--exclude=__pycache__',
        '--exclude=.pytest_cache',
        '--exclude=.ruff_cache',
        '--exclude=.mypy_cache',
        '--exclude=node_modules/.cache',
        '--exclude=.next',
        '--exclude=.nuxt',
        '--exclude=.turbo',
        str(origin_path) + '/',   # trailing slash = contents of directory
        str(worktree_path) + '/'
    ])

    # Import the Claude session
    imported_uuid = import_claude_session(origin_path, worktree_path, session_uuid)

    if not imported_uuid:
        warn("Session import failed. Starting fresh session.")
        session = create_session(
            project_name=project_name,
            branch=branch_name,
            worktree_path=worktree_path,
            origin_path=origin_path,
            source_branch=source_branch,
        )
        exit_code = run_claude_session(worktree_path, claude_args, session)
    else:
        info(f"Imported session: {imported_uuid}")
        session = create_session(
            project_name=project_name,
            branch=branch_name,
            worktree_path=worktree_path,
            origin_path=origin_path,
            source_branch=source_branch,
            claude_session_id=imported_uuid,
        )
        info(f"Session ID: {session.session_id}")

        # Run claude with --continue to resume the imported session
        import_args = ['--continue'] + list(claude_args)
        exit_code = run_claude_session(worktree_path, import_args, session)

    # Handle end of session
    handle_end_of_session(worktree_path, origin_path, session)

    return exit_code


# =============================================================================
# Main
# =============================================================================

def main():
    parser = argparse.ArgumentParser(
        description='Run Claude Code in a sandboxed user environment',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  yoloclaude https://github.com/user/repo     # Start new session with remote repo
  yoloclaude /path/to/local/repo              # Start new session with local repo
  yoloclaude myproject                        # Start new session (repo in ~/repos/)
  yoloclaude --resume                         # List sessions and pick one to resume
  yoloclaude --resume abc123                  # Resume session by ID
  yoloclaude --list                           # List all sessions
  yoloclaude myproject -w worktree-name       # Resume specific worktree directly
  yoloclaude myproject --list-worktrees       # List worktrees for a project
  yoloclaude myproject --clear-worktree=name  # Remove a specific worktree
  yoloclaude myproject --clear-worktrees      # Remove all worktrees for a project
  yoloclaude --import-claude                  # Import Claude session from current dir
  yoloclaude --import-claude /path/to/repo    # Import Claude session from specified path
  yoloclaude --import-claude . --session abc  # Import specific session by ID
  yoloclaude myproject --shell                # Drop into shell in worktree
  yoloclaude myproject -w name --shell        # Resume worktree in shell mode
        """
    )
    parser.add_argument(
        'repo',
        nargs='?',
        help='Git repository URL, local path, or project name'
    )
    parser.add_argument(
        'claude_args',
        nargs='*',
        help='Additional arguments to pass to claude'
    )
    parser.add_argument(
        '-y', '--yes',
        action='store_true',
        help='Non-interactive mode: answer yes to all prompts'
    )
    parser.add_argument(
        '-r', '--resume',
        nargs='?',
        const='__list__',
        metavar='SESSION_ID',
        help='Resume a previous session (shows list if no ID given)'
    )
    parser.add_argument(
        '-l', '--list',
        action='store_true',
        help='List all sessions'
    )
    parser.add_argument(
        '-w', '--worktree',
        metavar='NAME',
        help='Resume a specific worktree directly (supports prefix matching)'
    )
    parser.add_argument(
        '--list-worktrees',
        action='store_true',
        help='List worktrees for a project'
    )
    parser.add_argument(
        '--clear-worktree',
        metavar='NAME',
        help='Remove a specific worktree'
    )
    parser.add_argument(
        '--clear-worktrees',
        action='store_true',
        help='Remove all worktrees for a project'
    )
    parser.add_argument(
        '--import-claude',
        nargs='?',
        const='.',
        metavar='PATH',
        help='Import Claude session from local repo into yoloclaude sandbox'
    )
    parser.add_argument(
        '--session',
        metavar='SESSION_ID',
        help='Specific Claude session ID to import (used with --import-claude)'
    )
    parser.add_argument(
        '-s', '--shell',
        action='store_true',
        help='Drop into a shell instead of running Claude Code'
    )

    args = parser.parse_args()

    # Set global auto-yes flag
    global AUTO_YES
    AUTO_YES = args.yes

    # Check prerequisites
    check_sudo_access()

    claude_home = get_claude_home()
    if not claude_home.exists():
        error(
            f"Claude home directory {claude_home} does not exist.\n"
            "Have you run yoloclaude-setup?"
        )

    # Handle --list
    if args.list:
        cmd_list_sessions()
        sys.exit(0)

    # Handle --list-worktrees (requires a project name)
    if args.list_worktrees:
        if not args.repo:
            error("--list-worktrees requires a project name")
        cmd_list_worktrees(extract_repo_name(args.repo))
        sys.exit(0)

    # Handle --clear-worktree (requires a project name)
    if args.clear_worktree:
        if not args.repo:
            error("--clear-worktree requires a project name")
        cmd_clear_worktree(extract_repo_name(args.repo), args.clear_worktree)
        sys.exit(0)

    # Handle --clear-worktrees (requires a project name)
    if args.clear_worktrees:
        if not args.repo:
            error("--clear-worktrees requires a project name")
        cmd_clear_worktrees(extract_repo_name(args.repo))
        sys.exit(0)

    # Handle --resume
    if args.resume is not None:
        session_id = None if args.resume == '__list__' else args.resume
        exit_code = cmd_resume(session_id, args.claude_args, args.shell)
        sys.exit(exit_code)

    # Handle --import-claude
    if args.import_claude is not None:
        if args.shell:
            error("--shell cannot be used with --import-claude (import is Claude-specific)")
        import_path = Path(args.import_claude).resolve()
        exit_code = cmd_import_claude(import_path, args.session, args.claude_args)
        sys.exit(exit_code)

    # Commands below require a repo argument
    if not args.repo:
        parser.print_help()
        print()
        error("Please provide a repository, or use --resume to continue a previous session.")

    # Resolve repo to local path
    origin_path = resolve_repo_path(args.repo)
    info(f"Origin (your local repo): {origin_path}")

    # Handle --worktree: resume a specific worktree
    if args.worktree:
        exit_code = cmd_worktree_resume(origin_path.name, args.worktree, args.claude_args, args.shell)
        sys.exit(exit_code)

    # Start session (prompts if existing worktrees)
    exit_code = cmd_start_session(origin_path, args.claude_args, args.shell)
    sys.exit(exit_code)


if __name__ == '__main__':
    main()
